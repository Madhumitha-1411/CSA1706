from collections import deque

def is_solvable(state):
    inv_count = 0
    nums = [x for x in state if x != 0]
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[i] > nums[j]:
                inv_count += 1
    return inv_count % 2 == 0

def bfs(start, goal):
    queue = deque([(start, [])])
    visited = set()
    moves = {0: [1, 3], 1: [0, 2, 4], 2: [1, 5], 3: [0, 4, 6],
             4: [1, 3, 5, 7], 5: [2, 4, 8], 6: [3, 7], 7: [4, 6, 8], 8: [5, 7]}
    while queue:
        state, path = queue.popleft()
        if state == goal:
            return path
        visited.add(tuple(state))
        zero_pos = state.index(0)
        for move in moves[zero_pos]:
            new_state = state[:]
            new_state[zero_pos], new_state[move] = new_state[move], new_state[zero_pos]
            if tuple(new_state) not in visited:
                queue.append((new_state, path + [new_state]))
    return None

start = [1, 2, 3, 4, 0, 5, 6, 7, 8]
goal = [1, 2, 3, 4, 5, 0, 6, 7, 8]

if is_solvable(start):
    solution = bfs(start, goal)
    print("Solution Steps:")
    for step in solution:
        print(step)
else:
    print("This puzzle is not solvable.")
